const parser = require('../parser/src/index');
const fs = require('fs');
const util = require('util');
const process = require('process');


function main() {
  // Check args
  if (process.argv.length < 3) {
    console.error("Please list solidity files to process as args");
    process.exit(1);
  }

  // Parse contracts from input files
  let contracts = [];
  for (let i = 2; i < process.argv.length; i++) {
    contracts = contracts.concat(getContracts(process.argv[i]));
  }
  
  // Generate an .md file in docs folder per contract
  contracts.forEach(contract => {
    const doc = contractToDoc(contract);
    fs.writeFileSync(`docs/${contract.name}.sol.md`, doc);
  })
  
  // Update sidebars index
  const sidebars = JSON.parse(fs.readFileSync('website/sidebars.json').toString());
  sidebars['docs-contracts']['Contracts'] = contracts.map(contract => `${contract.name}.sol`);
  fs.writeFileSync('website/sidebars.json', JSON.stringify(sidebars, null, 2))
  return;
}

function getContracts(filePath) {
  const contents = fs.readFileSync(filePath).toString();
  const ast = parser.parse(contents);
  return ast.children.filter(n => n.type === 'ContractDefinition');
}

function contractToDoc(contract) {
  // console.log(util.inspect(contract, {depth: 7})); // Uncomment to check AST
  const toDoc = new ToDoc();
  contract.subNodes.forEach(node => toDoc.add(node));

  return `---
id: ${contract.name}.sol
title: ${contract.name}
---

${formatNatspec(contract)}

<AUTOGENERATED_TABLE_OF_CONTENTS>
---
${toDoc.items.join("\n---")}
`
}

class ToDoc {
  constructor() {
    this.items = [];
  }

  add(node) {
    if (this[node.type]) {
      this[node.type](node);
    }
  }

  FunctionDefinition(node) {
    const paramList = node.parameters.parameters.map(p => p.typeName.name);
    this.items.push(`
### \`function ${node.name}(${paramList.join(',')})\`
${formatNatspec(node)}`)
  }

  EventDefinition(node) {
    const paramList = node.parameters.parameters.map(p => p.typeName.name);
    this.items.push(`
### \`event ${node.name}(${paramList.join(',')})\`
${formatNatspec(node)}`)
  }
  
  ModifierDefinition(node) {
    const paramList = node.parameters.parameters.map(p => p.typeName.name);
    this.items.push(`
### \`modifier ${node.name}(${paramList.join(',')})\`
${formatNatspec(node)}`)
  }

  StateVariableDeclaration(node) {
    node.variables.filter(v => v.visibility === 'public').forEach(v => {
      this.items.push(`
### \`${v.typeName.name} ${v.visibility} ${v.name}\`
${formatNatspec(node)}`)
    })
  }
}

// TODO: Actually parse natspec comments
function formatNatspec(node) {
  if (!node.natspec) return '';

  const str = node.natspec
    .replace(/^(\s*\/\*\*\s*)/mg, '')
    .replace(/^(\s*\*+\/\s*)/mg, '')
    .replace(/^(\s*\**\s*)/mg, '')
    .replace(/^(\s*\/\/\/\s*)/mg, '');

  const docs = {};

  const entry = /@(\w+)\s+([\s\S]*?)(?=(?:@\w|$))/g;

  while (true) {
    const match = entry.exec(str);

    if (match === null) {
      break;
    }

    docs[match[1]] = (docs[match[1]] || []).concat(match[2]);
  }

//   return `
// ${(docs.dev || []).join('\n')}
// ${(docs.notice || []).join('\n')}
// `

  return str
}

try {
  main();
} catch (ex) {
  console.error(ex);
}
