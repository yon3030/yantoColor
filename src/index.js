import assert from 'assert'
import fs from 'fs'
import Mustache from 'mustache'
import React from 'react'
import ReactDOMServer from 'react-dom/server'
import ASTWalker from './ast/ast-walker'
import ContractDoc from './components/contract-doc'

const DIRECTORY_PATH_CONTRACTS = 'zeppelin-solidity/contracts/'
const DIRECTORY_PATH_MOCKS = `${DIRECTORY_PATH_CONTRACTS}mocks/`
const DIRECTORY_PATH_EXAMPLES = `${DIRECTORY_PATH_CONTRACTS}examples/`
const DIRECTORY_PATH_EXCLUDE = [DIRECTORY_PATH_MOCKS, DIRECTORY_PATH_EXAMPLES]

const TEMPLATE_PATH_SIDEBAR = 'src/tpl/sidebars.json.mustache'
const TEMPLATE_PATH_DOC = 'src/tpl/doc.md.mustache'

const OUTPUT_PATH_SIDEBAR = 'website/sidebars.json'
const OUTPUT_PATH_DOC = (docId) => `docs/${docId}.md`

const SECTION_ID_ROOT = 'UNCATEGORIZED'

const NODE_TYPE_SOURCE_UNIT = 'SourceUnit'
const NODE_TYPE_CONTRACT_DEFINITION = 'ContractDefinition'
const NODE_TYPE_FUNCTION_DEFINITION = 'FunctionDefinition'
const NODE_TYPE_MODIFIER_DEFINITION = 'ModifierDefinition'
const NODE_TYPE_EVENT_DEFINITION = 'EventDefinition'

/**
 * Entry point.
 */
function main(args) {
  assert(args.length > 2, 'Missing path to JSON file generated by the Solidity compiler.')
  const filepath = args[2]
  const data = JSON.parse(fs.readFileSync(filepath))
  generateSidebar(data)
  generateDocs(data)
}

/**
 * Generates sidebars.json file.
 */
function generateSidebar(data) {
  const { contracts } = data
  const sidebarTemplate = fs.readFileSync(TEMPLATE_PATH_SIDEBAR, 'utf-8')
  const sidebarView = buildSidebarView(contracts)
  const sidebarContent = Mustache.render(sidebarTemplate, sidebarView)
  fs.writeFileSync(OUTPUT_PATH_SIDEBAR, sidebarContent)
}

/**
 * Builds a view object for the sidebars.json file's Mustache template.
 */
function buildSidebarView(contracts) {
  const docsPerSection = getDocsPerSection(contracts)
  const entries = Object.entries(docsPerSection)
  const sortedEntries = entries.sort((entry1, entry2) => {
    return compareSectionIds(entry1[0], entry2[0])
  })
  const sections = []
  for (let i = 0; i < sortedEntries.length; ++i) {
    const [sectionId, docIds] = sortedEntries[i]
    const docs = buildSidebarViewDocs(docIds)
    sections.push({
      sectionId,
      docs,
      last: i === sortedEntries.length - 1
    })
  }
  return { sections }
}

/**
 * Populates each section with its corresponding docs.
 */
function getDocsPerSection(contracts) {
  const docsPerSection = {}
  for (const contract of Object.keys(contracts)) {
    const [path, contractName] = contract.split(':')
    if (shouldExcludePath(path)) {
      continue
    }
    const sectionId = buildSectionId(path)
    const docId = buildDocId(path, contractName)
    if (!(sectionId in docsPerSection)) {
      docsPerSection[sectionId] = [docId]
    }
    else {
      docsPerSection[sectionId].push(docId)
    }
  }
  return docsPerSection
}

/**
 * Decides whether the given path should be excluded from the sidebar sections.
 */
function shouldExcludePath(path) {
  return DIRECTORY_PATH_EXCLUDE.some(prefix => path.startsWith(prefix))
}

/**
 * Derives a section ID from the given path.
 * E.g.: path "/a/b/C.sol" yields ID "a_b_C".
 */
function buildSectionId(path) {
  const relativePath = path.substr(DIRECTORY_PATH_CONTRACTS.length)
  const directoryParts = relativePath.split('/').slice(0, -1)
  if (directoryParts.length === 0) {
    return SECTION_ID_ROOT
  }
  return directoryParts.join(' / ').toUpperCase()
}

/**
 * Derives a doc ID from the given path and contract name.
 * E.g.: path "/a/b/C.sol" and contract "Base" yield ID "a_b_C_Base".
 */
function buildDocId(path, contractName) {
  const relativePath = path.substr(DIRECTORY_PATH_CONTRACTS.length)
  const pathParts = relativePath.split('/')
  const directoryParts = pathParts.slice(0, -1)
  const filename = pathParts[pathParts.length - 1]
  const filenameWithoutExtension = filename.substr(0, filename.lastIndexOf('.'))
  const idParts = directoryParts.concat(filenameWithoutExtension)
  if (filenameWithoutExtension !== contractName) {
    idParts.push(contractName)
  }
  return idParts.join('_')
}

/**
 * Compares two section IDs. The root section is considered
 * greater than any other section.
 */
function compareSectionIds(id1, id2) {
  if (id1 === SECTION_ID_ROOT && id2 === SECTION_ID_ROOT) {
    return 0
  }
  else if (id1 === SECTION_ID_ROOT) {
    return 1
  }
  else if (id2 === SECTION_ID_ROOT) {
    return -1
  }
  else {
    return id1 < id2 ? -1 : id2 < id1 ? 1 : 0
  }
}

/**
 * Builds a view object for a given section in the sidebars.json
 * file's Mustache template.
 */
function buildSidebarViewDocs(docIds) {
  const docs = []
  const sortedDocIds = docIds.sort()
  for (let j = 0; j < sortedDocIds.length; ++j) {
    docs.push({
      docId: sortedDocIds[j],
      last: j === sortedDocIds.length - 1
    })
  }
  return docs
}

/**
 * Generates a doc file for each contract.
 */
function generateDocs(data) {
  const { sources } = data
  const docTemplate = fs.readFileSync(TEMPLATE_PATH_DOC, 'utf-8')
  const idToHyperlink = buildIdToHyperlink(sources)
  const docViews = buildDocViews(sources, idToHyperlink)
  for (const docView of docViews) {
    const docContent = Mustache.render(docTemplate, docView)
    fs.writeFileSync(OUTPUT_PATH_DOC(docView.docId), docContent)
  }
}

/**
 * Builds an object mapping AST node IDs to their corresponding
 * hyperlinks, where these resouces can be found within the docs.
 */
function buildIdToHyperlink(sources) {
  let state = { idToHyperlink: {} }
  const astWalker = buildBaseAstWalker()
  astWalker.setStartFunction(NODE_TYPE_CONTRACT_DEFINITION, contractDefinitionStartFunction)
  astWalker.setEndFunction(NODE_TYPE_CONTRACT_DEFINITION, contractDefinitionEndFunction)
  astWalker.setStartFunction(NODE_TYPE_FUNCTION_DEFINITION, codeDefinitionStartFunction)
  astWalker.setStartFunction(NODE_TYPE_MODIFIER_DEFINITION, codeDefinitionStartFunction)
  astWalker.setStartFunction(NODE_TYPE_EVENT_DEFINITION, codeDefinitionStartFunction)
  for (const source in sources) {
    const ast = sources[source].AST
    state = astWalker.walk(ast, state)
  }
  return state.idToHyperlink

  function contractDefinitionStartFunction(node, state) {
    const docId = buildDocId(state.absolutePath, node.name)
    const hyperlink = `${docId}.html`
    return {
      ...state,
      idToHyperlink: {
        ...state.idToHyperlink,
        [node.id]: hyperlink
      },
      currentHyperlink: hyperlink
    }
  }
  
  function contractDefinitionEndFunction(node, state) {
    const { currentHyperlink, ...updatedState } = state
    return updatedState
  }
  
  function codeDefinitionStartFunction(node, state) {
    return {
      ...state,
      idToHyperlink: {
        ...state.idToHyperlink,
        [node.id]: `${state.currentHyperlink}#${node.name}`
      }
    }
  }
}

/**
 * Builds a basic AST walker which annotates the walk's state
 * with the absolute path of the current source unit.
 */
function buildBaseAstWalker() {
  const astWalker = new ASTWalker()
  astWalker.setStartFunction(NODE_TYPE_SOURCE_UNIT, sourceUnitStartFunction)
  astWalker.setEndFunction(NODE_TYPE_SOURCE_UNIT, sourceUnitEndFunction)
  return astWalker

  function sourceUnitStartFunction(node, state) {
    return {
      ...state,
      absolutePath: node.absolutePath
    }
  }
  
  function sourceUnitEndFunction(node, state) {
    const { absolutePath, ...updatedState } = state
    return updatedState
  }
}

/**
 * Builds view objects for all doc files' Mustache templates.
 */
function buildDocViews(sources, idToHyperlink) {
  let state = { docs: [], idToHyperlink }
  const astWalker = buildBaseAstWalker()
  astWalker.setStartFunction(NODE_TYPE_CONTRACT_DEFINITION, contractDefinitionStartFunction)
  for (const source in sources) {
    const ast = sources[source].AST
    state = astWalker.walk(ast, state)
  }
  return state.docs

  function contractDefinitionStartFunction(node, state) {
    const docId = buildDocId(state.absolutePath, node.name)
    const docTitle = node.name
    const content = buildDocHtmlContent(node, state.absolutePath, state.idToHyperlink)
    return {
      ...state,
      docs: state.docs.concat([{
        docId,
        docTitle,
        content
      }])
    }
  }
}

/**
 * Builds doc's HTML content for the given contract definition.
 */
function buildDocHtmlContent(contractDefinition, absolutePath, idToHyperlink) {
  return ReactDOMServer.renderToStaticMarkup(
    <ContractDoc
      contractDefinition={contractDefinition}
      absolutePath={absolutePath}
      idToHyperlink={idToHyperlink}
    />
  )
}

if (require.main === module) {
  try {
    main(process.argv)
  }
  catch (err) {
    console.error(err)
  }
}
